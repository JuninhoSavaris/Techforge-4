Trilha3
    	// todos os arquivos com exercícios da trilha 3
Exercicio 1
class Veiculo {
  mover(): void {
    console.log("O veículo está se movendo");
  }
}

class Carro extends Veiculo {
  mover(): void {
    console.log("O carro está dirigindo");
  }
}

class Bicicleta extends Veiculo {
  mover(): void {
    console.log("A bicicleta está pedalando");
  }
}

// Exemplos de uso
const carro = new Carro();
const bicicleta = new Bicicleta();

carro.mover();      // Output: O carro está dirigindo
bicicleta.mover();  // Output: A bicicleta está pedalando

Exercicio 2

// Classe abstrata
abstract class FiguraGeometrica {
  abstract calcularArea(): number;
}

// Subclasse: Círculo
class Circulo extends FiguraGeometrica {
  constructor(public raio: number) {
    super();
  }

  calcularArea(): number {
    return Math.PI * this.raio ** 2;
  }
}

// Subclasse: Quadrado
class Quadrado extends FiguraGeometrica {
  constructor(public lado: number) {
    super();
  }

  calcularArea(): number {
    return this.lado ** 2;
  }
}

// Subclasse: Triângulo
class Triangulo extends FiguraGeometrica {
  constructor(public base: number, public altura: number) {
    super();
  }

  calcularArea(): number {
    return (this.base * this.altura) / 2;
  }
}

// Função que recebe um array de figuras e imprime suas áreas
function imprimirAreas(figuras: FiguraGeometrica[]): void {
  figuras.forEach((figura, index) => {
    console.log(`Área da figura ${index + 1}:`, figura.calcularArea());
  });
}

// Exemplo de uso
const figuras: FiguraGeometrica[] = [
  new Circulo(5),
  new Quadrado(4),
  new Triangulo(10, 6),
];

imprimirAreas(figuras);

Exercicio 3

// Classe base
class Pagamento {
  processar(): void {
    console.log("Processando pagamento...");
  }
}

// Subclasse: Pagamento com Cartão
class PagamentoCartao extends Pagamento {
  constructor(public numeroCartao: string, public valor: number) {
    super();
  }

  private validarCartao(): boolean {
    // Validação simples: verificar se possui 16 dígitos
    return /^\d{16}$/.test(this.numeroCartao);
  }

  processar(): void {
    if (this.validarCartao()) {
      console.log(`Pagamento de R$${this.valor.toFixed(2)} aprovado no cartão.`);
    } else {
      console.log("Número do cartão inválido!");
    }
  }
}

// Subclasse: Pagamento via Boleto
class PagamentoBoleto extends Pagamento {
  constructor(public valor: number) {
    super();
  }

  private gerarCodigoBoleto(): string {
    // Geração simples de código fictício
    return "23790.12345 12345.678901 12345.678901 1 234500000100";
  }

  processar(): void {
    const codigo = this.gerarCodigoBoleto();
    console.log(`Boleto gerado no valor de R$${this.valor.toFixed(2)}.`);
    console.log(`Código: ${codigo}`);
  }
}

// Função para processar qualquer tipo de pagamento (polimorfismo)
function processarPagamentos(pagamentos: Pagamento[]): void {
  pagamentos.forEach(p => p.processar());
}

// Exemplo de uso
const pagamentos: Pagamento[] = [
  new PagamentoCartao("1234567890123456", 200.5),
  new PagamentoCartao("999", 150.0), // Inválido
  new PagamentoBoleto(350.75),
];

processarPagamentos(pagamentos);

Exercicio 4

// Classe base
class Animal {
  private energia: number;

  constructor(energiaInicial: number = 50) {
    this.energia = energiaInicial;
  }

  // Método protegido para permitir que subclasses modifiquem energia
  protected alterarEnergia(valor: number): void {
    this.energia += valor;
  }

  // Método genérico de comer
  comer(valorEnergia: number): void {
    this.alterarEnergia(valorEnergia);
    console.log(`O animal comeu e ganhou ${valorEnergia} de energia.`);
  }

  statusEnergia(): void {
    console.log(`Energia atual: ${this.energia}`);
  }
}

// Subclasse: Leão
class Leao extends Animal {
  comer(): void {
    console.log("O leão está caçando...");
    
    // Gasta energia primeiro
    this.alterarEnergia(-20);
    console.log("O leão gastou 20 de energia caçando.");

    // Depois recupera energia com a presa
    this.alterarEnergia(40);
    console.log("O leão recuperou 40 de energia ao comer a presa.");
  }
}

// Subclasse: Pássaro
class Passaro extends Animal {
  comer(): void {
    console.log("O pássaro está bicando sementes...");
    this.alterarEnergia(10);
    console.log("O pássaro ganhou 10 de energia.");
  }
}

// Função usando polimorfismo
function alimentarAnimais(animais: Animal[]): void {
  animais.forEach(animal => {
    animal.comer();  // Polimorfismo: cada animal implementa comer() de forma diferente
    animal.statusEnergia();
    console.log("--------------------");
  });
}

// Exemplo de uso
const leao = new Leao(60);
const passaro = new Passaro(30);

const animais: Animal[] = [leao, passaro];

alimentarAnimais(animais);

Exercicio 5

// Classe abstrata
abstract class Funcionario {
  constructor(
    private nome: string,
    private salario: number
  ) {}

  getNome(): string {
    return this.nome;
  }

  getSalario(): number {
    return this.salario;
  }

  // Método abstrato — cada tipo de funcionário terá seu cálculo
  abstract calcularBonus(): number;
}

// Subclasse: Gerente
class Gerente extends Funcionario {
  calcularBonus(): number {
    return this.getSalario() * 0.10; // 10%
  }
}

// Subclasse: Operário
class Operario extends Funcionario {
  calcularBonus(): number {
    return this.getSalario() * 0.05; // 5%
  }
}

// Função que aplica polimorfismo ao calcular salários com bônus
function calcularSalarioComBonus(funcionarios: Funcionario[]): void {
  funcionarios.forEach(func => {
    const bonus = func.calcularBonus();
    const total = func.getSalario() + bonus;

    console.log(
      `${func.getNome()} — Salário Base: R$${func.getSalario().toFixed(2)} — Bônus: R$${bonus.toFixed(2)} — Total: R$${total.toFixed(2)}`
    );
  });
}

// Exemplo de uso
const funcionarios: Funcionario[] = [
  new Gerente("Ana", 8000),
  new Operario("Carlos", 3000),
  new Operario("João", 250

